<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>INTERLIS VALIDIERUNG IN QGIS</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./_assets/stylesheets/collab-theme.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />


  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# INTERLIS VALIDIERUNG IN QGIS
### M√∂glichkeiten und Ideen
</script></section><section  data-markdown><script type="text/template">
<!-- Oli's stage -->

## Wer wir sind

### Oliver Grimm @ [Geowerkstatt](https://www.geowerkstatt.ch/) 

### Dave Signer @ [OPENGIS.ch](https://www.opengis.ch/) 

<aside class="notes">
Wir arbeiten in Schweizer Softwarebuden, die sich beide den Open Source L√∂sungen im GIS Bereich verschrieben haben.
</aside>
</script></section><section  data-markdown><script type="text/template">
## Um was geht's

<!-- Dave's stage -->

- INTERLIS setzt **valide** Daten voraus
- Daten k√∂nnen in QGIS **geflickt** werden
<br/>

- Integration vom **ilivalidator** im **Model Baker**
- Von was man **tr√§umen** kann üòÉ

<aside class="notes">
Ein Hauptpfeiler des INTERLIS Ansatzes ist, dass die Daten <b>harmonisch</b> und <b>valide</b> sind.

In QGIS ist es m√∂glich die Daten zu flicken.

<i>Doch es ist etwas m√ºhsam anhand eines Log-Files die einzelnen Features / Koordinaten zu finden</i>

In dem letzten zwei Jahren wurde der ilivalidator quasi vollintegriert in QGIS Model Baker.
1. Die Daten m√ºssen <b>nicht exportiert</b> werden, sondern werden direkt im QGIS validiert.
2. Die <b>interaktive</b> Ergebnissliste kann helfen die Features zu <b>finden und fixen</b>.
3. Dazu eine Demo gleich

Und danach noch einen kleinen Ausblick, von was man tr√§umen k√∂nnte.
</aside>
</script></section><section  data-markdown><script type="text/template">
<!-- Dave's stage -->

## INTERLIS Validierung in QGIS

<video controls="controls">
<source src="assets/validator.webm" type="video/mp4">
</video>

<aside class="notes">

<b>Video:</b>

- Datenbank -> Model Baker -> Daten Validator
- Die Datenquelle wird automatisch erkannt, auch wenn mehrere Datenquellen im QGIS Projekt sind.

- Lassen wir ihn mal durchlaufen -> finden 12 Fehler: Geometrie√ºberschneidungen, falsch formatierte TID, Werte ausserhalb des Bereiches
- Navigieren wir durch die Fehler. Aktivieren wir das Aufl√§uchten und zentrieren (wie in Attributtabelle)
- Tats√§chlich sind es nicht so viele Fehler in diesem Beispiel, dennoch schr√§nken wir die Validierung noch etwas ein.
  - W√§hlen wir nur den Basket f√ºr das Topic "Nature" anhand des Beh√§lters
  - Nun sind es noch 4 Fehler. Wollen wir uns um die Geometriefehler sp√§ter k√ºmmern, deaktivieren wir die Geometriechecks
  - Noch ein Fehler
- Wollen wir diesen fixen, wir √∂ffnen das Formular 
  - sehen dass es die t_ili_tid nicht gibt (wir k√∂nnten nun die Formularkonfiguration dieses Layers anpassen, machen wir aber nicht) 
  - wir √∂ffnen die Attributtabelle, gehen auf den Feldkalkulator und updaten das ensprechende Feld mit der Korrekten UUID
- Schauen wir uns noch den Geometriefehler an, wir validieren nochmals und ber√ºcksichtigen Geometriechecks.
  - Wir k√∂nnen auf die fehlerhaften Koordinaten zoomen und mit dem St√ºtzpunkwerkzeug und der Hilfe des Snapping Tools, dies Fixen. St√ºtzpunkteditor ist ebenfalls cool.
- Wir k√∂nnen auch einzelne Constraints mit einem Konfigurationsfile ausschalten. 
- Dazu validieren wir das andere Topic. 
- Dann haben wir dieses File, haben von einzelnen Klassen und Attribute die constraints ausgeschaltet.
- Wir lassen es durchlaufen - haben noch den einen Fehler. 
- Dieser ist bereits benannt, dennoch k√∂nnen wir noch ein spezifischere Message hinzuf√ºgen.
</aside>
</script></section><section  data-markdown><script type="text/template">
<!-- Oli's stage -->

## Was passiert im Backend?
<aside class="notes">
... das war nun das Frontend im Model Baker Plugin, doch was passiert im Hintergrund?
</aside>
</script></section><section  data-markdown><script type="text/template">
<!-- Dave's stage -->

## Ideen

  - M√§chtigere **QGIS Tools**
  - **Vollintegration** der Constraints
  - ...
  - Live (**Subset**) Validierung 

<aside class="notes">
Es gibt einige Ideen, wie man das nun <b>noch besser</b> machen k√∂nnte.

QGIS Tools so zu verbessern: ZBs. der Topologiechecker - ersetzt aber INTERLIS Check nicht.

Integration der Constraints (herauslesen aus INTERLIS Compiler)

Problem, dass grosse Datens√§tze immer ganz validiert werden m√ºssen. Es gibt die M√∂glichkeit von Beh√§lter etc. aber die Daten k√∂nnen nicht immer einfach separiert werden. Deshalb die Idee der Subset validierung.

</aside>
</script></section><section  data-markdown><script type="text/template">
## PoC Live Validierung üé•

<!-- Oli's stage -->
</script></section><section  data-markdown><script type="text/template">
## Model Baker Frontend
</br>

#### √úbergeben einer Selektion
![selection](assets/validate-selection.png)

#### Aufzeichnung einer Session
![recordoids](assets/record-oids.png)

<aside class="notes">
Es gibt mehrere Ans√§tze, wie dies in Model Baker integriert werden k√∂nnte. Sie <b>schliessen sich nicht aus</b>.

<b>√úbergeben der OIDs aller selektierten Features. Auch m√∂glich "Selektierte Features des aktuellen Layers"</b>

<b>Pros</b>
- Straightforeward und leicht verst√§ndliche L√∂sung.
- Kann auch als Validierung des Layers (wenn alles selektiert ist) benutzt werden.

<b>Cons</b>
- Man muss den √úberblick √ºber alle Selektionen behalten. Man muss evtl. durch alle Layer gehen und die Selektion √ºberpr√ºfen. Vielleicht w√§r auch noch eine Option "Deselect all on all layers" hilfreich.
- Auch erfasst man vielleicht Features auf Kind-Layer, die dann m√ºhsam zu finden sind f√ºr die Selektion. Ein automatisches Ermitteln und Hinzuf√ºgen von referenzierten Features aber kann zu Loops und grossen Datenmengen f√ºhren, weshalb darauf verzichtet wird.

<b>Aufzeichnung aller Features, die ge√§ndert wurden (ihre OIDs) - k√∂nnte auch automatisch starten.</b>

<b>Pros</b>
- Es braucht keine manuelle Selektion.
- Man beh√§lt die OIDs der ge√§nderten Features √ºber mehrere "Speicherungen".

<b>Cons</b>
- Komplexit√§t / Verst√§ndlichkeit / Neue Komponente (Maintanance etc.)

</aside>
</script></section><section  data-markdown><script type="text/template">
## Model Baker Zusatzfunktion

#### Ermitteln der Nachbarn
![neighbours](assets/collect-neighbours.png)

<aside class="notes">
Sofern die Features Geometrien haben, sollen auch die OIDs der Nachbars-Features ermittelt und √ºbergeben werden.

Je nach Menge muss auf die Performance geachtet werden. Evtl. braucht es einen zus√§tzlichen Panel: "Collect neighbours" -> wenn man sieht es geht viel zu lange, soll man auch abbrechen k√∂nnen.
</aside>
</script></section><section  data-markdown><script type="text/template">
## Fragen?
<br>

#### Web: www.geowerkstatt.ch / www.opengis.ch
#### Emails: oliver.grimm@geowerkstatt.ch / david@opengis.ch 
#### Social: @GrimmOliver / @signedav@fosstodon.org
</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"none","slideNumber":false,"overview":true,"autoPlayMedia":true}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
